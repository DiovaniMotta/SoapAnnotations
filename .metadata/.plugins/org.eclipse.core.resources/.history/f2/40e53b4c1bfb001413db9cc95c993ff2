package org.soap.diovani.motta.manager;

import java.lang.reflect.Field;
import java.util.List;

import javax.xml.bind.PropertyException;

import org.ksoap2.serialization.SoapObject;
import org.soap.diovani.motta.annotations.SoapCollection;
import org.soap.diovani.motta.annotations.SoapProperty;
import org.soap.diovani.motta.annotations.SoapProperty.Type;
import org.soap.diovani.motta.annotations.entidades.ClassAnnotations;
import org.soap.diovani.motta.annotations.entidades.FieldAnnotations;
import org.soap.diovani.motta.types.CollectionsValue;
import org.soap.diovani.motta.types.PrimitiveValue;
import org.soap.diovani.motta.utils.Klasse;


/**
 * 
 * @author Diovani Bernardi da Motta
 * Data: 09/05/2015
 * Classe responsável por gerenciar o envio e recebimento de objetos enviados através de mensagens Soap para o servidor
 */
public class Session {

	/**
	 * Método responsável por desenpacotar um SoapObject retornado do WebService 
	 * @param classe a classe a qual se deseja retornar um objeto
	 * @param object o SoapObject que se deseja desenpacotar
	 * @return um novo objeto do web service.
	 * @throws PropertyException 
	 */
	public static <T> T parse(Class<T> classe,org.ksoap2.serialization.SoapObject object) throws PropertyException {
		T target = null;
		try {
			//crio uma instancia da classe recebida por parametro
			target = Klasse.instancialize(classe);
		} catch (Exception e) {
			e.printStackTrace();
			throw new IllegalArgumentException("Não foi possível criar um instância do objeto "+classe.getSimpleName()+".");
		}
		// retorno as anotações contidas na classe passada por parametro
		List<FieldAnnotations> fields = SessionCache.annotations(classe).getFields();
		Field field = null;
		Type propertyType = null;
		try
		{
			//itero todas as anotações feitas contidas na classe
			for(int i=0; i<fields.size(); i++){
				FieldAnnotations annotations = fields.get(i);
				field = annotations.getField();
				propertyType = annotations.getType();
				// retorno o atributo contido dentro do objeto
				Object campo = object.getProperty(i); 
				//verifico se o atributo iterado está contido na mensagem recebida pelo web service
				if(campo == null){
					continue;
				}
				Object valor = null;
				//retorno o tipo do campo iterado
				Class<?> tipoCampo = field.getType();
				//se a anotação for a anotação SoapProperty
				if(annotations.getAnnotation().equals(SoapProperty.class)){
					if(propertyType == Type.PRIMITIVE){
						PrimitiveValue primitiveValue = new PrimitiveValue();
						valor = primitiveValue.value(tipoCampo, campo);
					}
					if(propertyType == Type.COMPLEX){
						SoapObject aux = (SoapObject) campo;
						valor = parse(tipoCampo,aux);
					}
					field.setAccessible(true);	
					field.set(target,valor);
				}
				//se a anotação for a anotação SoapCollection
				if(annotations.getAnnotation().equals(SoapCollection.class)){
					Object instance = Klasse.instancialize(annotations.getField().getClass());
					// se o objeto nao for uma instancia da interface List
					if(!(instance instanceof List)){
						throw new ClassCastException("Somente é permitido usar a annotação SoapCollections para implementações da interface java.util.List");
					}
				}
				//se a anotação for a anotação SoapCollection
				if(annotations.getAnnotation().equals(SoapCollection.class)){
					SoapObject collections = (SoapObject) campo;
					Class<?> klass = annotations.getAnnotation();
					SoapCollection collection  = Klasse.instancialize(klass);
					if(collection == null){
						throw new ClassCastException("Não foi possível realizar a conversão.");
					}
					@SuppressWarnings("unused")
					T aux = Klasse.instancialize(collection.classe());
					CollectionsValue<T> collectionsValue = new CollectionsValue<T>();
					valor = collectionsValue.value(collection.classe(),collections);
				}
			}
		}
		catch(Exception exception)
		{
			exception.printStackTrace();
		}
		return target;
	}
	
	/**
	 * Método responsável por efetuar o empacotamento de um objeto complexo que será enviado via SOAP para um web service
	 * @param object o objeto que será enviado
	 * @param name o nome do objeto enviado
	 * @return um objeto SoapObject contendo os dados empacotados
	 * @throws Exception 
	 */
	public static SoapObject convert(Object object,String name) throws Exception{
		Class<?> kclasse = object.getClass();
		ClassAnnotations classAnnotations = SessionCache.annotations(kclasse);
		if(classAnnotations == null){
			throw new  NullPointerException();
		}
		String nameSpace = classAnnotations.getNamespace();
		if((nameSpace == null) || (nameSpace.isEmpty())){
			throw new NullPointerException("Defina a anotação SoapObject para a classe.");
		}
		//declaro o objeto que será retornado
		SoapObject soapObject = new SoapObject(nameSpace,name);
		// retorno as anotações contidas na classe passada por parametro
		List<FieldAnnotations> fields = SessionCache.annotations(kclasse).getFields();
		Field field = null;
		Type propertyType = null;
		//itero todas as anotações contidas na classe		
		for(FieldAnnotations f : fields){
			field = f.getField();
			propertyType = f.getType();
			if(f.getAnnotation().equals(SoapProperty.class)){
				// se o objeto for do tipo primitivo
				if(propertyType == Type.PRIMITIVE){
					Object aux = field.get(object);
					Class<?> tipoCampo = aux.getClass();
					PrimitiveValue primitiveValue = new PrimitiveValue();
					Object process = primitiveValue.value(tipoCampo,aux);
					soapObject.addProperty(f.getName(),process);
				}
				// se o objeto for do tipo complexo
				if(propertyType == Type.COMPLEX){
					Object aux = field.get(object);
				}
			}
			if(f.getAnnotation().equals(SoapCollection.class)){
				
			}
		}
		return soapObject;
	}
}
