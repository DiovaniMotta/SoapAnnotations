package org.soap.diovani.motta.manager;

import java.lang.reflect.Field;
import java.util.List;

import javax.jws.Oneway;

import org.ksoap2.serialization.PropertyInfo;
import org.ksoap2.serialization.SoapObject;
import org.soap.diovani.motta.annotations.SoapCollection;
import org.soap.diovani.motta.annotations.SoapProperty;
import org.soap.diovani.motta.annotations.SoapProperty.Type;
import org.soap.diovani.motta.annotations.entidades.FieldAnnotations;
import org.soap.diovani.motta.types.CollectionsValue;
import org.soap.diovani.motta.types.PrimitiveValue;
import org.soap.diovani.motta.utils.Klasse;


/**
 * 
 * @author Diovani Bernardi da Motta
 * Data: 09/05/2015
 * Classe responsável por gerenciar o envio e recebimento de objetos enviados através de mensagens Soap para o servidor
 */
public class Session {

	/**
	 * Método responsável por desenpacotar um SoapObject retornado do WebService 
	 * @param classe a classe a qual se deseja retornar um objeto
	 * @param object o SoapObject que se deseja desenpacotar
	 * @return um novo objeto do web service.
	 */
	public static <T> T parse(Class<T> classe,org.ksoap2.serialization.SoapObject object){
		T target = null;
		try {
			//crio uma instancia da classe recebida por parametro
			target = classe.newInstance();
		} catch (Exception e) {
			e.printStackTrace();
			throw new IllegalArgumentException("Não foi possível criar um instância do objeto "+classe.getSimpleName()+".");
		}
		// retorno as anotações contidas na classe passada por parametro
		List<FieldAnnotations> fields = SessionCache.annotations(classe).getFields();
		Field field = null;
		Type propertyType = null;
		try
		{
			int i = 0;
			//itero todas as anotações feitas contidas na classe
			for(FieldAnnotations annotations : fields){
				field = annotations.getField();
				propertyType = annotations.getType();
				Object campo = object.getProperty(i); //annotations.getName()
				//verifico se o atributo iterado está contido na mensagem recebida pelo web service
				if(campo == null){
					continue;
				}
				Object valor = null;
				//retorno o tipo do campo iterado
				Class<?> tipoCampo = field.getType();
				//se a anotação for a anotação SoapProperty
				if(annotations.getAnnotation().equals(SoapProperty.class)){
					if(propertyType == Type.PRIMITIVE){
						PrimitiveValue primitiveValue = new PrimitiveValue();
						valor = primitiveValue.value(tipoCampo, campo);
					}
					if(propertyType == Type.COMPLEX){
						SoapObject aux = (SoapObject) campo;
						valor = parse(tipoCampo,aux);
					}
					field.setAccessible(true);	
					field.set(target,valor);
				}
				//se a anotação for a anotação SoapCollection
				if(annotations.getAnnotation().equals(SoapCollection.class)){
					Object instance = Klasse.instancialize(annotations.getField().getClass());
					// se o objeto nao for uma instancia da interface List
					if(!(instance instanceof List)){
						throw new ClassCastException("Somente é permitido usar a annotação SoapCollections para implementações da interface java.util.List");
					}
				}
				//se a anotação for a anotação SoapCollection
				if(annotations.getAnnotation().equals(SoapCollection.class)){
					SoapObject collections = (SoapObject) campo;
					Class<?> klass = annotations.getAnnotation();
					SoapCollection collection  = Klasse.instancialize(klass);
					if(collection == null){
						throw new ClassCastException("Não foi possível realizar a conversão.");
					}
					T aux = Klasse.instancialize(collection.classe());
					CollectionsValue<T> collectionsValue = new CollectionsValue<T>();
					valor = collectionsValue.value(collection.classe(),collections);
				}
				i++;
			}
		}
		catch(Exception exception)
		{
			exception.printStackTrace();
		}
		return target;
	}
}
